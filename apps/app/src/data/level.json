{
  "beginner": "For beginner-level projects, the structure is kept as simple and minimal as possible to ensure easy understanding and quick start.\n\t The folder hierarchy should be shallow, typically only two levels deep.\n\t At the root, include essential files like README.md for project overview and package.json for dependencies and scripts.\n\t The 'src' folder contains the main application code, with a simple entry point such as index.js or index.ts. Inside 'src', have only a few folders like 'components' for UI elements and 'utils' for helper functions.\n\t Tests should be minimal and placed inside a 'tests' folder containing basic unit tests.\n\t The goal is to avoid complexity: no deep nesting, no advanced folder separation.\n\t This setup suits solo developers or learners focusing on small-scale projects with limited features and functionality.\n\t Documentation and configuration files are kept to a minimum or embedded within source files.",
  
  "intermediate": "Intermediate projects require a more balanced and organized folder structure to support growing complexity and team collaboration.\n\t The root directory typically contains README.md, package.json, a 'src' folder for source code, a 'config' folder for environment and application settings, a 'tests' folder with separated unit and integration tests, and a 'scripts' folder for build, deployment, and utility scripts.\n\t Inside 'src', organize code into logical units: 'components' for reusable UI parts, 'services' for business logic and API calls, 'utils' for helper functions, and 'hooks' if using frameworks like React.\n\t This separation improves maintainability and code clarity.\n\t The 'config' folder manages environment-specific settings, such as development and production variables.\n\t Tests are divided into unit and integration to cover different testing scopes.\n\t Scripts automate common tasks, easing development workflows.\n\t Folder nesting typically extends to three levels, enough to segregate features without overwhelming developers.\n\t This structure suits small teams or projects growing beyond basic functionality but not yet enterprise scale.",
  
  "advanced": "Startup-level projects need scalable, modular architectures to accommodate rapid growth, multiple developers, and evolving requirements.\n\t The root directory is more comprehensive, including 'src', 'config', 'tests', 'scripts', 'docs', and 'ci' folders.\n\t The 'src' folder breaks down further into functional layers such as 'api' for backend endpoints or network calls, 'components' for UI, 'services' for business logic and integrations, 'store' for state management, 'utils' for common helpers, 'hooks' for custom framework hooks, and 'middleware' for request/response processing. The 'config' folder contains environment setups, application configurations, and database settings.\n\t The 'tests' directory expands to include unit, integration, and end-to-end (e2e) tests to ensure robust coverage across components and user flows.\n\t The 'docs' folder hosts architectural diagrams, setup guides, and onboarding materials.\n\t The 'ci' folder includes continuous integration pipeline definitions and scripts for automated testing and deployment. Folder depth can go to four levels to segregate concerns clearly while keeping discoverability manageable.\n\t This structure supports collaborative teams working in agile environments, needing modularity and clear separation of layers for scaling and maintainability.",
  
  "expert": "Enterprise-level projects demand highly detailed, modular, and extensible folder structures designed to support large teams, multiple services, strict governance, and complex requirements typical of SaaS or large-scale applications\n\t The root directory is richly populated with folders such as 'src', 'config', 'tests', 'scripts', 'docs', 'ci', 'deployments', and 'monitoring'.\n\t The 'src' folder subdivides extensively into 'api' for service endpoints, 'components' for reusable UI modules, 'services' for core business logic, 'store' for advanced state management, 'utils' for generalized helpers, 'hooks' for custom lifecycle or reactive hooks, 'middleware' for request processing layers, 'plugins' for extendable modules, 'adapters' for integration layers, 'domain' to encapsulate business domain logic, and 'infrastructure' for platform-specific code.\n\t The 'config' folder manages a broad range of environment, database, security, and logging configurations, enabling precise control over deployment environments and compliance.\n\t The 'tests' folder includes comprehensive coverage: unit, integration, end-to-end, performance, and security tests, often integrated with CI/CD pipelines defined in the 'ci' folder, which hold multiple YAML or script files for automated build, test, release, and monitoring workflows.\n\t The 'deployments' directory contains infrastructure-as-code files for Kubernetes, Docker, cloud providers, and environment-specific deployment scripts.\n\t The 'monitoring' folder manages alert configurations, dashboards, and logs aggregation tools to ensure uptime and operational insights.\n\t Folder depth typically reaches five or more levels, reflecting the layered architecture and microservices approach common in enterprise applications.\n\t This setup supports cross-functional teams, strict security and compliance standards, extensive documentation, and robust operational tooling, ensuring maintainability, scalability, and governance at large scale.\n\t"
}
